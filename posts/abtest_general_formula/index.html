<!DOCTYPE html>
<html lang="">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Lluc Puig Codina">
    <meta name="description" content="https://llucpuigcodina.github.io">
    <meta name="keywords" content="blog, economics,personal">
    
    <meta property="og:site_name" content="Lluc Puig Codina">
    <meta property="og:title" content="Lluc Puig Codina">
    <meta property="og:description" content="">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://llucpuigcodina.github.io/posts/abtest_general_formula/">
    <meta property="og:image" content="https://llucpuigcodina.github.io">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="https://llucpuigcodina.github.io/posts/abtest_general_formula/">
    <meta name="twitter:image" content="https://llucpuigcodina.github.io">

    <base href="https://llucpuigcodina.github.io">
    <title>
  X &gt; MAX for independent but not identically distributed betas - Lluc Puig Codina
</title>

    <link rel="canonical" href="https://llucpuigcodina.github.io/posts/abtest_general_formula/">
    
    <link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700">
    <link rel="stylesheet" href="//cdn.rawgit.com/necolas/normalize.css/master/normalize.css">
    <link rel="stylesheet" href="https://llucpuigcodina.github.io/css/style.min.css">

    

    

    <link rel="icon" type="image/png" href="https://llucpuigcodina.github.io/images/logo.png" sizes="32x32"/>

    

    <meta name="generator" content="Hugo 0.89.2" />
  </head>

  <body class="">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">Lluc Puig Codina</a>
    <input type="checkbox" id="menu-control"/>
    <label class="menu-mobile  float-right " for="menu-control">
      <span class="btn-mobile  float-right ">&#9776;</span>
      <ul class="navigation-list">
        
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="https://llucpuigcodina.github.io/research/">Research</a>
            </li>
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="https://llucpuigcodina.github.io/teaching/">Teaching</a>
            </li>
          
            <li class="navigation-item  align-center ">
              <a class="navigation-link" href="https://llucpuigcodina.github.io/posts/">Blog</a>
            </li>
          
        
      </ul>
    </label>
  </section>
  

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    
</nav>


      <div class="content">
        
  <section class="container post">
  <article>
    <header>
      <h1 class="title">X &gt; MAX for independent but not identically distributed betas</h1>
      <h2 class="date">October 13, 2023</h2>

      
    </header>

    


<style>
body {
text-align: justify}
</style>
<p>In this post I provide a general formula for the probability that the realization of a beta distribution is larger than the realizations from a sequence of beta random variables, all of them being independent.</p>
<p>Assume <span class="math inline">\(p_j \sim \mathscr{B}(\alpha_j, \beta_j)\)</span>. We have J+1 independent but not identically distributed beta random variables, indexed from 0 to J, and we are interested in calculating <span class="math inline">\(\mathbb{P}(p_0 &gt; max\{p_1,\dots,p_J\})\)</span>. <span class="math inline">\(\alpha_j\)</span>’s and <span class="math inline">\(\beta_j\)</span>’s are restricted to the positive integers. A recursive formula in the style of the ones provided by <a href="https://www.evanmiller.org/bayesian-ab-testing.html#binary_abc">Evan Miller</a> is:</p>
<span class="math display">\[\begin{aligned}
\mathbb{P}(p_0 &gt; max\{p_1,\dots,p_J\}) = \mathbb{P}(p_0(\alpha_0, \beta_0) &gt; max\{p_1,\dots, p_{J-1}\}) - \left(\prod_{k=1}^{\beta_J}\frac{\beta_0+\beta_J-k}{\alpha_0 + \beta_0 + \beta_J - k} \right) \mathbb{P}(p_0(\alpha_0, \beta_0+\beta_J) &gt; max\{p_1,\dots,p_{J-1}\})
\end{aligned}\]</span>
<p>in the case where <span class="math inline">\(\alpha_J = 1\)</span>. The case in which <span class="math inline">\(\alpha_J &gt; 1\)</span> is given by:</p>
<span class="math display">\[\begin{aligned}
\mathbb{P}(p_0 &gt; max\{p_1,\dots,p_J\}) = \mathbb{P}(p_0(\alpha_0, \beta_0) &gt; max\{p_1,\dots, p_{J-1}\}) - \left(\prod_{k=1}^{\beta_J}\frac{\beta_0+\beta_J-k}{\alpha_0 + \beta_0 + \beta_J - k} \right) \left[ \mathbb{P}(p_0(\alpha_0, \beta_0+\beta_J) &gt; max\{p_1,\dots,p_{J-1}\}) + \sum_{i=2}^{\alpha_J} \left(\frac{\Gamma(\beta_J + i -1)}{\Gamma(\beta_J)\Gamma(i)}\right) \left( \prod_{s=1}^{i-1} \frac{\alpha_0 + i -1 -s}{\alpha_0 +i-1-s + \beta_0 + \beta_J} \right) \mathbb{P}(p_0(\alpha_0 + i -  1, \beta_0+\beta_J) &gt; max\{p_1,\dots,p_{J-1}\})  \right]
\end{aligned}\]</span>
<p>where</p>
<span class="math display">\[\begin{aligned}
\mathbb{P}(p_g &gt; p_m) = \sum_{i = 1}^{\alpha_g}\frac{B(\alpha_m + i - 1, \beta_g + \beta_m)}{(\beta_g+i-1)B(i,\beta_g)B(\alpha_m, \beta_m)}

\end{aligned}\]</span>
<p><span class="math inline">\(B\)</span> denotes the beta function. This object is typically of interest in the Beta-Binomial model and the Bayesian analysis of binary outcome Randomized Control Trials (A/B tests), where the prior on the probability of success is given by (conjugate) independent beta distributions.</p>
<p>Due to the reduction in dimension on the <span class="math inline">\(max\)</span> operator, it is a guarantee that the first equation will end up evaluating a bunch of the bottom equations. Each step reduces the dimension in 1 but requires <span class="math inline">\(\alpha_j\)</span> evaluations of the formula again so it’s computable in <span class="math inline">\(\mathcal{O}\left(\prod_{j=1}^J\alpha_j\right)\)</span> time. The formula can also be re-derived such that the sums happen over the <span class="math inline">\(\beta_j\)</span>’s, instead of the <span class="math inline">\(\alpha_j\)</span>’s but since the number of successes are typically much smaller than the failures it is more efficient to use the one provided here. They could also be combined, alternating to deliver computational time in <span class="math inline">\(\mathcal{O}\left(\prod_{j=1}^J \min \{\alpha_j, \beta_j \} \right)\)</span>.</p>
<p>This formula adds to what was already provided by Miller. Since calculation is quite burdensome I provide here a general R function based on the recursive nature of the formula. I do not know whether someone else has derived this formula elsewhere. I have search for a bit but haven’t found it, so I would appreciate if someone pointed me to such formula being discovered. In a future post or in an edit to this post I will provide some derivation steps.</p>
<p>To calculate <span class="math inline">\(\mathbb{P}(p_i &gt; max\{p_0, p_1, \dots, p_{i-1}, p_{i+1}, \dots p_J\})\)</span> one only needs to reorder the <span class="math inline">\(\alpha_j\)</span>’s and <span class="math inline">\(\beta_j\)</span>’s appropriately. From simple rules of probability where <span class="math inline">\(P(A_1 \cap A_2) = P(A_1) - P(A_1 - A_2)\)</span> we can obtain that the negative term corresponds to the probability of the following event: <span class="math inline">\(p_J &gt; p_0 &gt; max\{p_1,\dots,p_{J-1}\}\)</span>; that <span class="math inline">\(p_J\)</span> is the largest and <span class="math inline">\(p_0\)</span> the second largest. This object could also be of interest, specially due to the possibility of reordering to calculate any event of the type <span class="math inline">\(p_k &gt; p_g &gt; max\{p_1,\dots,p_{k-1},p_{k+1}, \dots,p_{g-1},p_{g+1},\dots,p_J\}\)</span> and possibly other sequences of inequalities by going down the recursive rabbit hole. The relation with order statistics as just seen and the recursive nature, and thus combinatorial evaluations of the function, give some <a href="http://library.isical.ac.in:8080/jspui/bitstream/10263/5036/1/Order%20statistics%20for%20nonidentically%20distributed%20variables%20and%20permanents-S-51-1-1989-P79-93.pdf">Bapat-Beg Theorem</a> taste. It also makes me suspect of a close relationship between the maximum of beta random variables and the beta distribution itself.</p>
<pre class="r"><code>ProbMBeatsG &lt;- function(ag, bg, am, bm){
  Bf &lt;- sapply(1:ag, function(i) {exp(lbeta(am + i - 1, bg + bm) - 
                                            log(bg + i - 1) - lbeta(i, bg) - lbeta(am, bm))})   
  return(sum(Bf))  
}

InnerTerm &lt;- function(i, a0, b0, aJ, bJ, aS, bS){
  s = 1:(i - 1)
  return( exp(lgamma(bJ + i - 1) - lgamma(bJ) - lgamma(i))*prod((a0 + i - 1 - s)/(a0  + i - 1 - s + b0 + bJ))*Prob0beatsAll(a0 + i - 1, b0 + bJ, head(aS, -1), head(bS, -1)) )  
}

Prob0beatsAll &lt;- function(alpha0, beta0, alpha_, beta_){
  
  J = length(alpha_)
  
  if (J == 1) {
    
    return(ProbMBeatsG(alpha0, beta0, alpha_, beta_))
  
    } else {
      
      alphaJ = alpha_[J]
      betaJ = beta_[J]
      k = 1:betaJ
      multip &lt;- prod( (beta0 + betaJ - k)/(alpha0 + beta0 + betaJ - k) )
      
      if (alpha_[J] == 1) {
        
        return(  Prob0beatsAll(alpha0, beta0, head(alpha_, -1), head(beta_, -1))
                 -multip*Prob0beatsAll(alpha0, beta0 + betaJ, head(alpha_, -1), head(beta_, -1)) )
        
      } else{
        return( Prob0beatsAll(alpha0, beta0, head(alpha_, -1), head(beta_, -1))
                - multip*Prob0beatsAll(alpha0, beta0 + betaJ, head(alpha_, -1), head(beta_, -1))
                - multip*sum(sapply(2:(alphaJ), InnerTerm, a0 = alpha0, b0 = beta0, aJ = alphaJ, bJ = betaJ,
                                aS = alpha_, bS = beta_)) )
      }
    }
}</code></pre>
<pre class="r"><code>alpha0 = 5
beta0 = 5
alpha_ &lt;- c(5,5,5)
beta_ &lt;- c(5,5,5)

print(Prob0beatsAll(alpha0, beta0, alpha_, beta_)) # This confirms the 1/(J+1) case of iid variables.</code></pre>
<pre><code>## [1] 0.25</code></pre>

  </article>

  <br/>

  
  
</section>

      </div>
      
        <footer class="footer">
  <section class="container">
    © 2023 · Lluc Puig Codina

  </section>
</footer>

      
    </main>

    

  <script src="https://llucpuigcodina.github.io/js/app.js"></script>
  
  <script>
  (function($) {
    $(function() {
      $('#privateTrigger').on('click', function() {
        $('.private').slideToggle();
        $('#privateTriggerText').text(" ");
      });
    });
   })(jQuery);
  </script>
  
  </body>
</html>
